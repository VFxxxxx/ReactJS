
Урок 6. Методы жизненного цикла компонента, умные и глупые компоненты
=====================================================================

Итак, пришло время двигаться дальше.

В прошлом уроке мы определяли наши компоненты в виде функций. Но есть возможность создать компонент в виде класса и тогда у него будут доступны так называемые методы жизненного цикла.

Для начала, пример компонента-класса:

```
class Profile extends React.Component {
  render() {
    return (
      <div>
        <img src="http://i.pravatar.cc/300" />
        <h1>{this.props.name} {this.props.surname}</h1>
        <p>Возраст: {this.props.age}</p>
        <p>Пол: {this.props.gender}</p>
        <p>О себе: {this.props.about}</p>
      </div>
    )
  }
}

ReactDOM.render(
  <Profile
    age='25'
    gender='мужской'
    about='Немного обо мне..'
  />,
  document.getElementById('root')
)
```

Данный компонент выводит профиль некой персоны.

В конце урока 4 я описывал как работают классы в ES6, так что повторяться не буду. Единственно замечу, что создание классов это возможность JavaScript, а не нечто, специфичное именно для React, просто последний это использовал для своих нужд. Это пояснение, чтобы не было путаницы.

Так вот, общий формат таков. Ключевое слово class, затем имя класса, а точнее компонента в нашем случае, затем ключевое слово extends и React.Component.

extends означает что нужно расширить то что было у класса React.Component и добавить к нему то, что есть в классе Profile. Если будут методы или свойства с одинаковыми именами, то использоваться будут те, что объявлены в Profile.


=== Методы жизненного цикла

Методы жизненного цикла вызываются разные, в разном количестве и последовательности в зависимости от того что происходит:
1) создается ли компонент
2) обновляется ли он
3) уничтожается
4) или произошла ошибка.

Вот в этой части документации вы всегда можете найти эти полезные списки методов.


==  Mounting

Рассмотрим создание (маунтинг).

Статический метод getDerivedStateFromProps исключим из рассмотрения - он нам сейчас не нужен.

Теперь я перепишу предыдущий компонент так, чтобы можно было убедиться в порядке вызова методов. Я для этого расставил console.log'и:

```
class Profile extends React.Component {
  constructor (props) {
    super(props)
    console.log(1, 'constructor')
  }

  componentWillMount() {
    console.log(2, 'UNSAFE_componentWillMount')
  }

  componentDidMount() {
    console.log(4, 'componentDidMount')
  }

  render() {
    console.log(3, 'first render')

    return (
      <div>
        <img src="http://i.pravatar.cc/300" />
        <h1>{this.props.name} {this.props.surname}</h1>
        <p>Возраст: {this.props.age}</p>
        <p>Пол: {this.props.gender}</p>
        <p>О себе: {this.props.about}</p>
      </div>
    )
  }
}
```

Сначала вызывается метод constructor - это момент создания экземпляра компонента.

Потом componentWillMount, говорящий что сейчас начнется маунтинг, но его не рекомендуют использовать в современном коде.

Далее render - вызывается при каждой перерисовке компонента - в случае маунтинга это именно первая отрисовка компонента

Ну и наконец componentDidMount сигнализирует что компонент создан (причем он не будет больше вызываться до тех пор, пока компонент не будет создан еще раз или вновь).

Теперь, в зависимости от того, чего вы хотите достичь, вы будете свой код писать в те или иные места.

Фактически методы жизненного цикла это ключевые точки в абстрактной жизни компонента. Можно провести аналогии с жизнью любого живого существа. Собственно, поэтому такое название.

В конструкторе например привязываются контексты к методам, в которых контекст this теряется, а это обработчки событий на элементах DOM-дерева.

В componentDidMount удобно что-то сделать, когда разметка компонента гарантированно собрана и отрендерена. Например, привязать вручную обработчики событий, хотя как правило для этого используют синтетические события самого React'а.

В начале метода render можно проверять какое-то условие, например, пришли ли нам данные с сервера для отрисовки профиля или нет. Если нет, возвращаем null и не рисуем ничего. Если же есть - рисуем профиль.

А вообще, вы будете делать в этих методах именно, то что нужно исходя из логики вашего приложения. Хотя есть выработанные временем рекомендации какие типовые действия стоит в каком месте писать. Об этом можно узнать из многочисленных статей и уроков по React. Изучайте по максимуму.


=== Updating

Теперь рассмотрим цикл обновления.


```
class Profile extends React.Component {
  constructor (props) {
    super(props)
    console.clear()
  }

  shouldComponentUpdate(nextProps, nextState) {
    console.log(2, 'shouldComponentUpdate')
    return true
  }

  componentWillUpdate(nextProps, nextState) {
    console.log(3, 'UNSAFE_componentWillUpdate')
  }

  componentWillReceiveProps(nextProps) {
    console.log(1, 'UNSAFE_componentWillReceiveProps')
  }

  componentDidUpdate(prevProps, prevState) {
    console.log(5, 'componentDidUpdate')
  }
  
  render() {
    console.log(4, 'render')

    return (
      <div>
        <img src="http://i.pravatar.cc/300" />
        <h1>{this.props.name} {this.props.surname}</h1>
        <p>Возраст: {this.props.age}</p>
        <p>Пол: {this.props.gender}</p>
        <p>О себе: {this.props.about}</p>
      </div>
    )
  }
}

class App extends React.Component {
  state = {
    age: 25
  }

  newRandomAge = () => {
    this.setState({
      age: Math.ceil(Math.random() * 100)
    })
  }

  render() {
    return (
      <div>
        <button onClick={this.newRandomAge}>Rerender</button>

        <Profile
          age={this.state.age}
          gender='мужской'
          about='Немного обо мне..'
        />
      </div>
    )
  }
}

ReactDOM.render(
  <App />,
  document.getElementById('root')
)
```


Исключаем из рассмотрения неважные пока методы getDerivedStateFromProps() и getSnapshotBeforeUpdate().

Здесь уже сложнее. Я создал компонент App, который внутри себя рисует компонент Profile. Также, тут я создал кнопку, которой на клик присвоил написанный мной метод newRandomAge, который занимается тем, что записывает в стейт компонента случайное значение возраста.

И тут вопрос - а что же такое этот стейт? Ничего сверхъестественного, просто часть класса, которая хранит определенные данные. Причем когда мы хотим туда что-то записать, мы делаем это не напрямую, в виде this.state (this, напомню всегда ссылается на сам компонент, или на класс, если угодно), а используя метод setState, который был унаследован нашим компонентом благодаря вот этому extends - о нем я уже говорил ранее.

Можно тогда возразить, мол а почему ты сам написал state = {age: 25}? Ответ прост - это начальное значение стейта и его можно записать именно так. Эта инициализация значения стейта будет производить только один раз при маунтинге компонента.

Другим вариантом была бы вот такая запись:

```
constructor (props) {
  super(props)

  this.state = {
    age: 25
  }
}
```

Так, через конструктор тоже будет работать. Главное не забыть приписать this.

Можно еще увидеть и другой способ записи (https://reactjs.org/docs/react-without-es6.html#setting-the-initial-state)
Вот он - в документации. Но это способ записи актуален, если вы не используете возможности ES6, чего сегодня делать категорически не стоит.

Теперь очень важный момент. Реакт работает таким образом, что при изменении стейта дергается перерисовка компонента. Это же касается и изменения пропсов, которые приехали в компонент. Именно поэтому отображение определяется состоянием, то есть данными, записанными в компоненте в виде стейта и пропсов.

Видно, что в качестве пропса Profile принимает не конкретную цифру, а текущее значение age, взятое из стейта компонента App. И изменение пропса триггерует перерисовку Profile.

В данный момент, все должно начать проясняться. При клике на кнопку, генерируется случайное значение возраста? Оно пишется в стейт App, что вызывает его метод render, где Profile перерисовывается c новым актуальным значением age из стейта App. А это, в свою очередь, дергает метод render уже внутри Profile, так как изменение пропсов является сигналом для перерисовки.

Реакт достаточно умен, чтобы не перерисовывать в реальном DOM'е то, что не изменилось. Именно для этого существует так называемый виртуальный DOM. Сначала все вычисляется в памяти компьютера, а затем уже действительная разница рисуется в окне браузера. Это работает потому, что рисовать на экран намного медленнее, нежели вычислять все это в памяти. Поэтому, такой подход работает и экономит огромное количество ресурсов.

Теперь наконец рассмотрим, что происходит в измененном компоненте Profile.

Я вызываю конструктор, просто чтобы при маунтинге компонента очистить консоль - это для удобства.
А так, конструктор не входит в цикл обновления.

Первым же в этом цикле у нас вызывается метод componentWillReceiveProps (дословно: компонент примет пропсы) и в первом аргументе там будут новые пропсы, которые можно сравнить с теми, что были до этого. Ведь заметьте, на этом этапе новый рендер еще не произошел. Метод не рекомендуется к использованию в современном React-коде и помечен как UNSAFE.

Дальше вызывается метод shouldComponentUpdate (буквальный перевод: следует ли компонент обновить) и в нем можно словить следующие пропсы и следующий стейт для того, чтобы понять, надо ли перерисовать компонент или нет. Чтобы это делать всегда, я сейчас возвращаю true из этого метода. Если этого не сделать, то перерисовки просто-напросто не произойдет. В реальной же ситуации не всегда нужно перерисовывать компонент, когда у него поменялся стейт или пропсы, так что в зависимости от нужного условия мы можем вернуть true или false, тем самым убрав лишние перерисовки и, соответственно, потенциально улучшить производительность нашего приложения.

Следующим вызывается также UNSAFE-метод componentWillUpdate (непосредственно перед обновлением компонента, до рендера). Принимает nextProps и nextState, чем внутри него и можно пользоваться.

Потом у нас рендер, с которым вы уже знакомы.

Ну и завершает цикл componentDidUpdate - компонент был обновлен. Принимает уже prevProps и prevState, то есть уже предыдущие пропсы и стейт, те что были ДО случившегося шагом ранее рендера.


=== Unmounting

Ну и теперь последний цикл - анмаунтинг. То есть когда компонент уничтожается.

А когда компонент уничтожается? Ответ прост. Когда из метода render возвращается null. Реакт отслеживает, когда компонент возвращает ничего и для него это сигнал убрать из реального DOM'а созданную разметку. В виртуальном DOM'е при этом останется сам компонент, а вот в реальном.. Ну давайте приведу пример.

```
class Profile extends React.Component {
  constructor (props) {
    super(props)
    console.clear()
  }

  componentWillUnmount() {
    console.log('componentWillUnmount')
  }

  render() {
    return (
      <div>
        <img src="http://i.pravatar.cc/300" />
        <h1>{this.props.name} {this.props.surname}</h1>
        <p>Возраст: {this.props.age}</p>
        <p>Пол: {this.props.gender}</p>
        <p>О себе: {this.props.about}</p>
      </div>
    )
  }
}

class App extends React.Component {
  constructor (props) {
    super(props)
  }
 
  state = {
    age: 25
  }

  newRandomAge = () => {
    this.setState({
      age: Math.ceil(Math.random() * 100)
    })
  }

  render() {
    return (
      <div>
        <button onClick={this.newRandomAge}>Rerender</button>

        {
          this.state.age < 50
            ? (
              <Profile
                age={this.state.age}
                gender='мужской'
                about='Немного обо мне..'
              />
            )
            : null
        }
        
      </div>
    )
  }
}

ReactDOM.render(
  <App />,
  document.getElementById('root')
)
```

Сейчас я переписал код таким образом, что Profile рисуется только если кнопкой мы генерируем возраст, меньший чем 50. В первый раз рендер происходит, так что есть основания для того, чтобы компонент, если в очередной раз выпадет число большее или равное 50-ти, уничтожился. До того как это произойдет, вызовется как раз метод componentWillUnmount и мы увидим вывод в консоли. Именно это сейчас и произошло.

Этот метод часто используется для отвязки обработчиков и уничтожения созданных таймеров, особенно если в компоненте реализуется что-то, что привязано к отсчету времени. Все это делается, как вы понимаете, для экономии памяти.

Кстати, для отладки react-приложений вам стоит установить плагин React Developer Tools для Chrome. Он помогает видеть DOM в виде React-компонентов, смотреть на пропсы и на стейт. Короче, архиполезная штука.

Ну и чтобы воспользоваться этим в среде CodePen, необходимо в графе Change View выбрать Debug Mode. Не забудьте сохранить пен. Тогда откроется отдельное окно и в нем девтулзы будут работать нормально.

Тут это не работает из-за iframe'а. Подробно про CodePen я рассказывал в другом своем ролике на просторах ютуб-канала MakeWeb.me. Ознакомьтесь, если не очень уверенно себя чувствуете в интерфейсе этого сервиса.


Ну вот, это и были те самые методы жизненного цикла. Как видите, в них ничего сверъестественного нет, просто нужно один раз вникнуть.



=== Умные и глупые компоненты

Теперь коснемся важной концепции про умные (или иначе компоненты-контейнеры) и глупые (иначе - презентационные) компоненты. Она отчасти связана с определением компонентов через классы и через функции. Сейчас поясню.

Глупый компонент характеризуется так:
- он определяет КАК все выглядит и обычно содержит внутри себя разметку и стилизацию,
- может рисовать внутри себя как глупые, так и умные компоненты
- не имеет своих методов и в том числе методов жизненного цикла
- не имеет своего стейта
- принимает данные для отрисовки исключительно через пропсы от родителя, что рисовал его.

И вот связь с началом ролика: глупые компоненты определяются как функции, а не как классы. Таким образом можно создавать более эффективные компоненты. Действительно, зачем компоненту нужны какие-то там методы внутри себя, если все что надо можно взять в пропсах? Незачем таскать тогда с собой и методы жизненного цикла, если все так просто. Поэтому и такой способ определения компонента.

Теперь про умный компонент:
- он определяет КАК все работает и как правило не содержит в себе разметки и стилизации
- также может рисовать внутри себя как глупые, так и умные компоненты
- передает вычисленные или запрошенные с сервера данные в пропсах для глупых компонентов
- имеет стейт, методы жизненного цикла, обработчики событий и прочее

И вот умные компоненты уже точно нужно определять как классы.

```
const Profile = (props) => {
  return (
    <div>
      <img src="http://i.pravatar.cc/300" />
      <h1>{props.name} {props.surname}</h1>
      <p>Возраст: {props.age}</p>
      <p>Пол: {props.gender}</p>
      <p>О себе: {props.about}</p>
    </div>
  )
}

class App extends React.Component {
  state = {
    age: 25
  }

  newRandomAge = () => {
    this.setState({
      age: Math.ceil(Math.random() * 100)
    })
  }

  render() {
    return (
      <div>
        <button onClick={this.newRandomAge}>Rerender</button>

        <Profile
          age={this.state.age}
          gender='мужской'
          about='Немного обо мне..'
        />
      </div>
    )
  }
}

ReactDOM.render(
  <App />,
  document.getElementById('root')
)
```

Посмотрите на вот этот пример - тут я переписал профиль в виде функции, сделав таким образом компонент глупым. Пропсы прилетают в виде аргумента props и я к ним обращаюсь уже без this.

Можно кстати записать не через стрелочную функцию, а по старинке вот так, если вам привычнее:

```
const Profile = function (props) {
  return (
    <div>
      <img src="http://i.pravatar.cc/300" />
      <h1>{props.name} {props.surname}</h1>
      <p>Возраст: {props.age}</p>
      <p>Пол: {props.gender}</p>
      <p>О себе: {props.about}</p>
    </div>
  )
}
```

Это вариант Function Expression.

Или даже вот так (вариант Function Declaration):

```
function Profile (props) {
  return (
    <div>
      <img src="http://i.pravatar.cc/300" />
      <h1>{props.name} {props.surname}</h1>
      <p>Возраст: {props.age}</p>
      <p>Пол: {props.gender}</p>
      <p>О себе: {props.about}</p>
    </div>
  )
}
```
Все это вполне рабочие варианты, но рекомендую привыкать к новому синтаксису - он короче и имеет чрезвычайно полезные особенности.
Вот так будет еще короче:

```
const Profile = (props) => (
  <div>
    <img src="http://i.pravatar.cc/300" />
    <h1>{props.name} {props.surname}</h1>
    <p>Возраст: {props.age}</p>
    <p>Пол: {props.gender}</p>
    <p>О себе: {props.about}</p>
  </div>
)
```
Подразумевается, что то, что в скобочках является значением, возвращаемым из функции, так что явно писать return не надо.

Ну а как пример компонента-контейнера, перед вами имеется App. В нем вы сможете найти все характерные черты данного вида компонентов, описанные выше - объявлен как класс, имеет стейт, методы и так далее.

===
Вообще, надо сказать, что описанное деление на умные и глупые компоненты не фигурирует в явном виде в документации к Реакту. Это введено Деном Абрамовым, разаработчиком популярной библиотеки Redux, которая добавляет важный функционал, которого нет у чистого реакта.

Но концепция очень жизненная и правильная, так что имейте ее ввиду.
